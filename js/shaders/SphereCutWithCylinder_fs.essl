shaderSource[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	uniform vec4 lightPos[10];
	uniform vec4 lightPowerDensity[10];
	uniform samplerCube envmapTexture;
	varying vec4 rayDir;
	//varying vec2 texCoord;
	uniform vec3 camPos;
	uniform sampler2D colorTexture;


	float intersectionT(vec3 eye, vec3 ray){

		//vec3 r = normalize(ray);

		//vec3 e = normalize(eye);

		vec4 eyePos = vec4(eye, 1);
		vec4 rayDir = vec4(ray, 0);

		//-1 = eyePos.x + rayDir.x(t);

		mat4 A = mat4	(1,0,0,0,
						0, 1, 0, 0,
						0, 0, 1, 0,
						0, 0, 0, -9);

		mat4 A1 = mat4 (1,0,0,0,
						0,1,0,0,
						0,0,0,0,
						0,0,0,-2);

		//equation to solve:
		//dot(rayDir * A, rayDir) * t^2 + dot(rayDir*A, eyePos) * t + dot(eyePos*A, rayDir) * t + dot(eyePos*A, eyePos) = 0;
		float a = dot(rayDir * A, rayDir);
		float b = dot(rayDir*A, eyePos) + dot(eyePos*A, rayDir);
		float c = dot(eyePos*A, eyePos);

		float D = b*b-4.0*a*c;
		if (D<0.0){
		return -1.0;
		}

		float t1 = (-b + sqrt(D)) / (2.0*a);
		float t2 = (-b - sqrt(D)) / (2.0*a);

		float t = min(t1,t2);

		if (t<0.0){
		t = max(t1,t2);
		}

		float a1 = dot(rayDir * A1, rayDir);
		float b1 = dot(rayDir*A1, eyePos) + dot(eyePos*A1, rayDir);
		float c1 = dot(eyePos*A1, eyePos);

		if (a1*(pow(t,2.0))+b1*t+c1 <= 0.0){
				t=max(t1,t2);
				if (a1*(pow(t,2.0))+b1*t+c1 <= 0.0){
					return -1.0;
				}
				return t;
		}

		return t;
	}

	void main(void) {
		mat4 A = mat4	(1,0,0,0,
						0, 1, 0, 0,
						0, 0, 1, 0,
						0, 0, 0, -9);
		vec2 rayCoords = normalize((normalize(rayDir.xyz) + vec3(0,0,1))).xy*vec2(0.5,-0.5) + vec2(0.5,0.5);
		if (intersectionT(camPos, rayDir.xyz) < 0.0){
			gl_FragColor = texture2D(colorTexture, rayCoords);
		}else{
			vec4 intersectionPoint = vec4((camPos + rayDir.xyz*intersectionT(camPos, rayDir.xyz)),1);
			vec3 n  = normalize((A*intersectionPoint+intersectionPoint*A).xyz);
			gl_FragColor = vec4(n,1);
		}

	}


`;